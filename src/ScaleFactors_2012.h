// lines below are generated by the script 
// hmumuAnalysis/pklFilesMuonPOG/createArraysSF.py

const int etaBins = 13;
const int ptBins = 11;
 
double etaRange[etaBins+1] = {-2.1, -1.6, -1.2, -0.9, -0.6, -0.3, -0.2,
                              0.2, 0.3, 0.6, 0.9, 1.2, 1.6, 2.1};
 
double ptRange[ptBins+1] = {10, 20, 25, 30, 35, 40, 50, 60, 90, 140, 300, 500};
 
 
// 2012ABCD ID/Iso
double MuonIdTight_2012ABCD[etaBins] = {
  0.990058361324 , 
  0.997579936964 , 
  0.989590182856 , 
  0.995016682376 , 
  0.995065148584 , 
  0.985835911615 , 
  0.993582252364 , 
  0.984757188952 , 
  0.995213174487 , 
  0.993107696183 , 
  0.991302609865 , 
  1.00086625194 , 
  0.999594414483 , 
};


double PFIsoIddB_eta09_2012ABCD[ptBins] = {
  0.947049705422 , 
  0.97497776756 , 
  0.997128807241 , 
  0.99386327999 , 
  0.993441774626 , 
  0.994100660511 , 
  0.995543810157 , 
  0.999035883598 , 
  1.00104129441 , 
  1.00029970163 , 
  1.01977297451 , 
};


double PFIsoIddB_eta09to12_2012ABCD[ptBins] = {
  0.951835554757 , 
  0.988367918025 , 
  1.00083445494 , 
  0.998545596012 , 
  0.999140394617 , 
  0.998176265943 , 
  0.998695565448 , 
  0.999132326799 , 
  0.999559422931 , 
  0.996767366991 , 
  1.00784406192 , 
};


double PFIsoIddB_eta12to21_2012ABCD[ptBins] = {
  0.980044923028 , 
  0.997342368141 , 
  1.00783703626 , 
  1.00684843673 , 
  1.00369937841 , 
  1.00209284302 , 
  1.0012468208 , 
  1.00065433176 , 
  0.999877975484 , 
  0.99989003675 , 
  1.0139231777 , 
};


// Trigger efficiencies split by run periods
// 2012 A 
double TrigId_2012A[etaBins] = {
  0.986858337843 , 
  0.978316370924 , 
  0.953292931894 , 
  0.95987914314 , 
  0.961398047798 , 
  0.90902735272 , 
  0.952102875987 , 
  0.934788940021 , 
  0.965820891251 , 
  0.965678787559 , 
  0.953722570873 , 
  0.952339791663 , 
  1.00869615784 , 
};


double effData_TrigId_2012A[etaBins] = {
  0.753767295526 , 
  0.819571556724 , 
  0.819496231244 , 
  0.898127266652 , 
  0.911663831552 , 
  0.813118266202 , 
  0.893659937712 , 
  0.832459445263 , 
  0.915513012049 , 
  0.902093528013 , 
  0.816940817437 , 
  0.78902027997 , 
  0.810787455195 , 
};


double effMC_TrigId_2012A[etaBins] = {
  0.763804962294 , 
  0.837736729224 , 
  0.859647862505 , 
  0.935667029616 , 
  0.948268860791 , 
  0.894492628598 , 
  0.938616992187 , 
  0.890531979599 , 
  0.947911792282 , 
  0.934154855253 , 
  0.856581192882 , 
  0.828507101013 , 
  0.80379750522 , 
};


// 2012 B 
double TrigId_2012B[etaBins] = {
  0.978390329954 , 
  0.983240259733 , 
  0.960283547369 , 
  0.980383168804 , 
  0.986638317618 , 
  0.941567671449 , 
  0.979740173253 , 
  0.957931506297 , 
  0.986491632773 , 
  0.983868548375 , 
  0.963627869262 , 
  0.951537268303 , 
  1.01178235504 , 
};


double effData_TrigId_2012B[etaBins] = {
  0.747299389079 , 
  0.82369647923 , 
  0.825505698894 , 
  0.91731220744 , 
  0.93559839346 , 
  0.842225341437 , 
  0.919600774544 , 
  0.853068640622 , 
  0.935107051693 , 
  0.919085581395 , 
  0.825425509747 , 
  0.788355383667 , 
  0.81326813281 , 
};


double effMC_TrigId_2012B[etaBins] = {
  0.763804962294 , 
  0.837736729224 , 
  0.859647862505 , 
  0.935667029616 , 
  0.948268860791 , 
  0.894492628598 , 
  0.938616992187 , 
  0.890531979599 , 
  0.947911792282 , 
  0.934154855253 , 
  0.856581192882 , 
  0.828507101013 , 
  0.80379750522 , 
};


// 2012 C 
double TrigId_2012C[etaBins] = {
  0.993505794239 , 
  0.99932115235 , 
  0.968357227737 , 
  0.984348692042 , 
  0.991151581866 , 
  0.946845904327 , 
  0.987094067516 , 
  0.95725034454 , 
  0.988669415988 , 
  0.987690315773 , 
  0.969185226572 , 
  0.981921303256 , 
  1.03205674648 , 
};


double effData_TrigId_2012C[etaBins] = {
  0.766595741817 , 
  0.84453568564 , 
  0.841980279385 , 
  0.932696875418 , 
  0.953701730285 , 
  0.859889140733 , 
  0.941531735035 , 
  0.865874245837 , 
  0.951220788751 , 
  0.935057743014 , 
  0.840023792384 , 
  0.820795500622 , 
  0.837836289733 , 
};


double effMC_TrigId_2012C[etaBins] = {
  0.771606714588 , 
  0.845109386161 , 
  0.86949346302 , 
  0.947526910899 , 
  0.962215818179 , 
  0.908161652074 , 
  0.953841954906 , 
  0.90454315402 , 
  0.962122195113 , 
  0.946711462167 , 
  0.866731940761 , 
  0.835907621008 , 
  0.81181223086 , 
};


// 2012 D 
double TrigId_2012D[etaBins] = {
  0.996325392684 , 
  0.996709394012 , 
  0.961403094194 , 
  0.9807378886 , 
  0.987351488544 , 
  0.947109971177 , 
  0.984566165998 , 
  0.959141789157 , 
  0.985612535107 , 
  0.985765932383 , 
  0.962322189252 , 
  0.978560167836 , 
  1.01645754825 , 
};


double effData_TrigId_2012D[etaBins] = {
  0.756529249797 , 
  0.826816885228 , 
  0.82044391028 , 
  0.914407512793 , 
  0.933199042067 , 
  0.843924838898 , 
  0.920971940502 , 
  0.850853638616 , 
  0.931033366577 , 
  0.917330589348 , 
  0.817689735738 , 
  0.80371346111 , 
  0.812877883127 , 
};


double effMC_TrigId_2012D[etaBins] = {
  0.759319450605 , 
  0.829546596225 , 
  0.853381807521 , 
  0.932366867255 , 
  0.945153831127 , 
  0.891052638639 , 
  0.935408885972 , 
  0.887098913044 , 
  0.944624112837 , 
  0.930576477856 , 
  0.849704750519 , 
  0.821322477173 , 
  0.799716510076 , 
};




// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !!!!            Do not remove the lines below                !!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
int findEtaBin(_MuonInfo& mu) {
 
  int value = -999;

  // find the eta bins of both muons
  for (int ieta=0; ieta<etaBins; ieta++) {
    if ( mu.eta > etaRange[ieta] && mu.eta < etaRange[ieta+1] ) 
      return ieta;
  }

  return value;
}


int findPtBin(_MuonInfo& mu) {
  
  int value = -999;
  //std::cout << "mu.pt = " << mu.pt <<std::endl;
  
  // find the eta bins of both muons
  for (int ipt=0; ipt<ptBins; ipt++) {
    if ( mu.pt > ptRange[ipt] && mu.pt < ptRange[ipt+1] ) 
      return ipt;
  }
  
  return value;
}



// 2012 ABCD ID/ISO
double
weightFromSF_ID_ISO_ABCD(_MuonInfo& mu1, _MuonInfo& mu2,
                         double varMuId  , 
                         double varIsoId )
{

  // initialization
  int iEta1=-999, iPt1=-999;
  int iEta2=-999, iPt2=-999;

  iEta1=findEtaBin(mu1);
  iPt1 =findPtBin (mu1);

  iEta2=findEtaBin(mu2);
  iPt2 =findPtBin (mu2);

  //std::cout << "weightFromSF_ID_ISO_ABCD\n";
  //std::cout << "mu1.pt = " << mu1.pt << "->" << iPt1 << std::endl;
  //std::cout << "mu2.pt = " << mu2.pt << "->" << iPt2 << std::endl;
  //std::cout << "mu1.eta = " << mu1.eta << "->" << iEta1 << std::endl;
  //std::cout << "mu2.eta = " << mu2.eta << "->" << iEta2 << std::endl;

  //sanity check  
  if (iEta1 == -999) return 1; 
  if (iPt1  == -999) return 1; 
  if (iEta2 == -999) return 1;
  if (iPt2  == -999) return 1;


  // compute the weights
  double weight = 1;
  
  weight *= (MuonIdTight_2012ABCD[iEta1]+varMuId);
  weight *= (MuonIdTight_2012ABCD[iEta2]+varMuId);

  //std::cout << "weight after ID = " << weight << std::endl;

  if (fabs(mu1.eta) < 0.9)   weight *= (PFIsoIddB_eta09_2012ABCD[iPt1]+varIsoId);
  if (fabs(mu1.eta) > 0.9 &&
      fabs(mu1.eta) < 1.2  ) weight *= (PFIsoIddB_eta09to12_2012ABCD[iPt1]+varIsoId);
  if (fabs(mu1.eta) > 1.2 &&
      fabs(mu1.eta) < 2.1  ) weight *= (PFIsoIddB_eta12to21_2012ABCD[iPt1]+varIsoId);

  if (fabs(mu2.eta) < 0.9)   weight *= (PFIsoIddB_eta09_2012ABCD[iPt2]+varIsoId);
  if (fabs(mu2.eta) > 0.9 &&
      fabs(mu2.eta) < 1.2  ) weight *= (PFIsoIddB_eta09to12_2012ABCD[iPt2]+varIsoId);
  if (fabs(mu2.eta) > 1.2 &&
      fabs(mu2.eta) < 2.1  ) weight *= (PFIsoIddB_eta12to21_2012ABCD[iPt2]+varIsoId);

  //std::cout << "weight after ID*ISO = " << weight << std::endl;

  return weight;

}


// 2012
double
weightFromTrigger(_MuonInfo& mu1, _MuonInfo& mu2,
                  const double effData_TrigId[], 
                  const double effMC_TrigId[],
                  const double TrigId[],
                  double varTrigId)
{

  // initialization
  int iEta1=-999, iPt1=-999;
  int iEta2=-999, iPt2=-999;

  iEta1=findEtaBin(mu1);
  iPt1 =findPtBin (mu1);

  iEta2=findEtaBin(mu2);
  iPt2 =findPtBin (mu2);
  
  //std::cout << "mu1.eta,mu1.pt = " << mu1.eta<< ", " << mu1.pt <<std::endl;
  //std::cout << "iEta1,iPt1 = " << iEta1 << "," << iPt1 << std::endl;
  //std::cout << "mu2.eta,mu2.pt = " << mu2.eta<< ", " << mu2.pt <<std::endl;
  //std::cout << "iEta2,iPt2 = " << iEta2 << "," << iPt2 << std::endl;

  //sanity check  
  if (iEta1 == -999) return 1; 
  if (iPt1  == -999) return 1; 
  if (iEta2 == -999) return 1;
  if (iPt2  == -999) return 1;


  // compute the weights
  double weight = 1;

  // eff = 1 - (1-eff_mu1)*(1-eff_mu2)
  // SF = eff_Data/eff_MC
  double effHLTData = 1 - ( (1-effData_TrigId[iEta1])*(1-effData_TrigId[iEta2]) );
  double effHLTMC   = 1 - ( (1-effMC_TrigId  [iEta1])*(1-effMC_TrigId  [iEta2]) );

  double weightTrigger = 1;
  if (mu1.pt > 25 && mu2.pt > 25) weightTrigger = effHLTData / effHLTMC;
  if (mu1.pt > 25 && mu2.pt < 25) weightTrigger = TrigId[iEta1]; 
  if (mu1.pt < 25 && mu2.pt > 25) weightTrigger = TrigId[iEta2]; 

  weight *= (weightTrigger+varTrigId);

  // debugging
  //std::cout << "weightFromTrigger=" << weight << std::endl;

  return weight;

}




double
weightFromSF(double random,
             _MuonInfo& mu1, _MuonInfo& mu2,
             double varMuId  , 
             double varIsoId ,
             double varTrigId)
{

  //std::cout << "In weightFromSF... " << std::endl;
  double weight = 1;
  weight *= weightFromSF_ID_ISO_ABCD(mu1,mu2, varMuId,varIsoId); // ID + ISO

  //std::cout << "weight=" << weight << std::endl;
  // trigger requires more work ;-)
  // 2012AB is ~5 fb-1
  // 2012C  is ~7fb-1
  // 2012D  is ~7fb-1
  // so use the 2012AB SF if the random number is < 0.25
  //std::cout << "random = " << random << std::endl;

  if (random < 0.25) {
    //std::cout << "2012AB values\n";
    weight *= weightFromTrigger(mu1,mu2, 
                                effData_TrigId_2012B,
                                effMC_TrigId_2012B,
                                TrigId_2012B,
                                varTrigId); // Trigger
    
  } else if (random < 0.62){
    //std::cout << "2012C values\n";
    weight *= weightFromTrigger(mu1,mu2, 
                                effData_TrigId_2012C,
                                effMC_TrigId_2012C,
                                TrigId_2012C,
                                varTrigId); // Trigger
  }
  
  else {
    //std::cout << "2012D values\n";
    weight *= weightFromTrigger(mu1,mu2, 
                                effData_TrigId_2012D,
                                effMC_TrigId_2012D,
                                TrigId_2012D,
                                varTrigId); // Trigger
  }


  return weight;
}




