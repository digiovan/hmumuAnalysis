// The lines below are generated by the script 
// hmumuAnalysis/pklFilesMuonPOG/createArraysSF.py

const int etaBins = 13;
const int ptBins = 8;
 
double etaRange[etaBins+1] = {-2.1, -1.6, -1.2, -0.9, -0.6, -0.3, -0.2,
                              0.2, 0.3, 0.6, 0.9, 1.2, 1.6, 2.1};
 
double ptRange[ptBins+1] = {25, 30, 35, 40, 50, 60, 90, 140, 500};
 
 
// 2012AB ID/Iso
double MuonIdTight_2012AB[etaBins] = {
  0.988724932665 , 
  0.996737842371 , 
  0.986031140836 , 
  0.991124275065 , 
  0.989706987927 , 
  0.980364354197 , 
  0.987307178012 , 
  0.980522774477 , 
  0.992104552844 , 
  0.988883091109 , 
  0.99028808593 , 
  0.999737137335 , 
  0.997319526433  
};


double PFIsoIddB_eta09_2012AB[ptBins] = {
  0.991942388206 , 
  0.992135342011 , 
  0.993091518388 , 
  0.994310585549 , 
  0.995081603823 , 
  0.997969711328 , 
  0.999642125778 , 
  0.995084252461  
};


double PFIsoIddB_eta09to12_2012AB[ptBins] = {
  0.994168947061 , 
  0.996334832917 , 
  0.997334033959 , 
  0.997840943267 , 
  0.997123646502 , 
  0.996624751108 , 
  0.998533439643 , 
  0.997348599329 , 
};


double PFIsoIddB_eta12to21_2012AB[ptBins] = {
  0.999085718239 , 
  1.00067227076 , 
  1.00016439461 , 
  0.999862399229 , 
  1.0004112741 , 
  0.999233934088 , 
  0.997440031884 , 
  0.996480472038  
};


// Trigger efficiencies split by run periods
double TrigId_2012A[etaBins] = {
  0.986858337843 , 
  0.978316370924 , 
  0.953292931894 , 
  0.95987914314 , 
  0.961398047798 , 
  0.90902735272 , 
  0.952102875987 , 
  0.934788940021 , 
  0.965820891251 , 
  0.965678787559 , 
  0.953722570873 , 
  0.952339791663 , 
  1.00869615784  
};


double TrigId_2012B[etaBins] = {
  0.978390329954 , 
  0.983240259733 , 
  0.960283547369 , 
  0.980383168804 , 
  0.986638317618 , 
  0.941567671449 , 
  0.979740173253 , 
  0.957931506297 , 
  0.986491632773 , 
  0.983868548375 , 
  0.963627869262 , 
  0.951537268303 , 
  1.01178235504  
};


// 2012C ID/Iso/Trigger
double MuonIdTight_2012C[etaBins] = {
  0.988885203691 , 
  0.997645965784 , 
  0.988640905096 , 
  0.995901914593 , 
  0.996042652393 , 
  0.985086426679 , 
  0.993679777153 , 
  0.983066759579 , 
  0.995857745381 , 
  0.994146529356 , 
  0.992398250305 , 
  1.00046379301 , 
  1.00429584132  
};


double PFIsoIddB_eta09_2012C[ptBins] = {
  1.00096011705 , 
  0.995690948085 , 
  0.994869044087 , 
  0.994939272615 , 
  0.996388682635 , 
  0.998466713263 , 
  1.00057425897 , 
  1.00230050167  
};


double PFIsoIddB_eta09to12_2012C[ptBins] = {
  1.00114794697 , 
  1.00012043148 , 
  0.99882351994 , 
  0.998772141875 , 
  0.997179142478 , 
  0.998559850765 , 
  0.997776185356 , 
  0.997745177092  
};


double PFIsoIddB_eta12to21_2012C[ptBins] = {
  1.00835309635 , 
  1.00612938524 , 
  1.00341477933 , 
  1.00195376157 , 
  1.00058592603 , 
  1.0012846555 , 
  0.999173409208 , 
  0.994603362486  
};


double TrigId_2012C[etaBins] = {
  0.993505794239 , 
  0.99932115235 , 
  0.968357227737 , 
  0.984348692042 , 
  0.991151581866 , 
  0.946845904327 , 
  0.987094067516 , 
  0.95725034454 , 
  0.988669415988 , 
  0.987690315773 , 
  0.969185226572 , 
  0.981921303256 , 
  1.03205674648  
};




// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !!!!            Do not remove the lines below                !!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
int findEtaBin(_MuonInfo& mu) {
 
  int value = -999;

  // find the eta bins of both muons
  for (int ieta=0; ieta<etaBins; ieta++) {
    if ( mu.eta > etaRange[ieta] && mu.eta < etaRange[ieta+1] ) 
      return ieta;
  }

  return value;
}


int findPtBin(_MuonInfo& mu) {
  
  int value = -999;
  //std::cout << "mu.pt = " << mu.pt <<std::endl;
  
  // find the eta bins of both muons
  for (int ipt=0; ipt<ptBins; ipt++) {
    if ( mu.pt > ptRange[ipt] && mu.pt < ptRange[ipt+1] ) 
      return ipt;
  }
  
  return value;
}



// 2012 AB
double
weightFromSF_AB(_MuonInfo& mu1, _MuonInfo& mu2,
                double varMuId  , 
                double varIsoId ,
                double varTrigId)
{

  // initialization
  int iEta1=-999, iPt1=-999;
  int iEta2=-999, iPt2=-999;

  iEta1=findEtaBin(mu1);
  iPt1 =findPtBin (mu1);

  iEta2=findEtaBin(mu2);
  iPt2 =findPtBin (mu2);

  //sanity check  
  if (iEta1 == -999) return 1; 
  if (iPt1  == -999) return 1; 
  if (iEta2 == -999) return 1;
  if (iPt2  == -999) return 1;

  // compute the weights
  double weight = 1;
  
  weight *= (MuonIdTight_2012AB[iEta1]+varMuId);
  weight *= (MuonIdTight_2012AB[iEta2]+varMuId);

  if (fabs(mu1.eta) < 0.9)   weight *= (PFIsoIddB_eta09_2012AB[iPt1]+varIsoId);
  if (fabs(mu1.eta) > 0.9 &&
      fabs(mu1.eta) < 1.2  ) weight *= (PFIsoIddB_eta09to12_2012AB[iPt1]+varIsoId);
  if (fabs(mu1.eta) > 1.2 &&
      fabs(mu1.eta) < 2.1  ) weight *= (PFIsoIddB_eta12to21_2012AB[iPt1]+varIsoId);

  if (fabs(mu2.eta) < 0.9)   weight *= (PFIsoIddB_eta09_2012AB[iPt2]+varIsoId);
  if (fabs(mu2.eta) > 0.9 &&
      fabs(mu2.eta) < 1.2  ) weight *= (PFIsoIddB_eta09to12_2012AB[iPt2]+varIsoId);
  if (fabs(mu2.eta) > 1.2 &&
      fabs(mu2.eta) < 2.1  ) weight *= (PFIsoIddB_eta12to21_2012AB[iPt2]+varIsoId);


  if (mu1.isHltMatched[0] != 0) weight *= (TrigId_2012B[iEta1]+varTrigId);
  if (mu2.isHltMatched[0] != 0) weight *= (TrigId_2012B[iEta2]+varTrigId);

  return weight;

}

// 2012C
double
weightFromSF_C(_MuonInfo& mu1, _MuonInfo& mu2,
               double varMuId  , 
               double varIsoId ,
               double varTrigId)
{

  // initialization
  int iEta1=-999, iPt1=-999;
  int iEta2=-999, iPt2=-999;

  iEta1=findEtaBin(mu1);
  iPt1 =findPtBin (mu1);

  iEta2=findEtaBin(mu2);
  iPt2 =findPtBin (mu2);
  
  //std::cout << "mu1.eta,mu1.pt = " << mu1.eta<< ", " << mu1.pt <<std::endl;
  //std::cout << "iEta1,iPt1 = " << iEta1 << "," << iPt1 << std::endl;
  //std::cout << "mu2.eta,mu2.pt = " << mu2.eta<< ", " << mu2.pt <<std::endl;
  //std::cout << "iEta2,iPt2 = " << iEta2 << "," << iPt2 << std::endl;

  //sanity check  
  if (iEta1 == -999) return 1; 
  if (iPt1  == -999) return 1; 
  if (iEta2 == -999) return 1;
  if (iPt2  == -999) return 1;


  // compute the weights
  double weight = 1;

  weight *= (MuonIdTight_2012C[iEta1]+varMuId);
  weight *= (MuonIdTight_2012C[iEta2]+varMuId);

  if (fabs(mu1.eta) < 0.9)   weight *= (PFIsoIddB_eta09_2012C[iPt1]+varIsoId);
  if (fabs(mu1.eta) > 0.9 &&
      fabs(mu1.eta) < 1.2  ) weight *= (PFIsoIddB_eta09to12_2012C[iPt1]+varIsoId);
  if (fabs(mu1.eta) > 1.2 &&
      fabs(mu1.eta) < 2.1  ) weight *= (PFIsoIddB_eta12to21_2012C[iPt1]+varIsoId);

  if (fabs(mu2.eta) < 0.9)   weight *= (PFIsoIddB_eta09_2012C[iPt2]+varIsoId);
  if (fabs(mu2.eta) > 0.9 &&
      fabs(mu2.eta) < 1.2  ) weight *= (PFIsoIddB_eta09to12_2012C[iPt2]+varIsoId);
  if (fabs(mu2.eta) > 1.2 &&
      fabs(mu2.eta) < 2.1  ) weight *= (PFIsoIddB_eta12to21_2012C[iPt2]+varIsoId);


  if (mu1.isHltMatched[0] != 0) weight *= (TrigId_2012C[iEta1]+varTrigId);
  if (mu2.isHltMatched[0] != 0) weight *= (TrigId_2012C[iEta2]+varTrigId);

  return weight;

}



double
weightFromSF(double random,
             _MuonInfo& mu1, _MuonInfo& mu2,
             double varMuId  , 
             double varIsoId ,
             double varTrigId)
{

  double weight = 1;

  // 2012AB is 5 fb-1
  // Assume 2012C is equal to 2012D
  // so use the 2012AB SF if the random number is < 0.25
  //std::cout << "random = " << random << std::endl;

  if (random < 0.25) {
    //std::cout << "2012AB values\n";
    weight *= weightFromSF_AB(mu1,mu2, varMuId,varIsoId,varTrigId);
  } else {
    //std::cout << "2012C values\n";
    weight *= weightFromSF_C (mu1,mu2, varMuId,varIsoId,varTrigId);
  }

  return weight;
}



