// The lines below are generated by the script 
// hmumuAnalysis/pklFilesMuonPOG/createArraysSF.py

const int etaBins = 13;
const int ptBins = 8;
 
double etaRange[etaBins+1] = {-2.1, -1.6, -1.2, -0.9, -0.6, -0.3, -0.2,
                              0.2, 0.3, 0.6, 0.9, 1.2, 1.6, 2.1};
 
double ptRange[ptBins+1] = {25, 30, 35, 40, 50, 60, 90, 140, 500};
 
 
// // 2012AB ID/Iso
// double MuonIdTight_2012AB[etaBins] = {
//   0.988724932665 , 
//   0.996737842371 , 
//   0.986031140836 , 
//   0.991124275065 , 
//   0.989706987927 , 
//   0.980364354197 , 
//   0.987307178012 , 
//   0.980522774477 , 
//   0.992104552844 , 
//   0.988883091109 , 
//   0.99028808593 , 
//   0.999737137335 , 
//   0.997319526433  
// };
// 
// 
// double PFIsoIddB_eta09_2012AB[ptBins] = {
//   0.991942388206 , 
//   0.992135342011 , 
//   0.993091518388 , 
//   0.994310585549 , 
//   0.995081603823 , 
//   0.997969711328 , 
//   0.999642125778 , 
//   0.995084252461  
// };
// 
// 
// double PFIsoIddB_eta09to12_2012AB[ptBins] = {
//   0.994168947061 , 
//   0.996334832917 , 
//   0.997334033959 , 
//   0.997840943267 , 
//   0.997123646502 , 
//   0.996624751108 , 
//   0.998533439643 , 
//   0.997348599329 , 
// };
// 
// 
// double PFIsoIddB_eta12to21_2012AB[ptBins] = {
//   0.999085718239 , 
//   1.00067227076 , 
//   1.00016439461 , 
//   0.999862399229 , 
//   1.0004112741 , 
//   0.999233934088 , 
//   0.997440031884 , 
//   0.996480472038  
// };
// 
// 
// // Trigger efficiencies split by run periods
// double TrigId_2012A[etaBins] = {
//   0.986858337843 , 
//   0.978316370924 , 
//   0.953292931894 , 
//   0.95987914314 , 
//   0.961398047798 , 
//   0.90902735272 , 
//   0.952102875987 , 
//   0.934788940021 , 
//   0.965820891251 , 
//   0.965678787559 , 
//   0.953722570873 , 
//   0.952339791663 , 
//   1.00869615784  
// };
// 
// 
// double TrigId_2012B[etaBins] = {
//   0.978390329954 , 
//   0.983240259733 , 
//   0.960283547369 , 
//   0.980383168804 , 
//   0.986638317618 , 
//   0.941567671449 , 
//   0.979740173253 , 
//   0.957931506297 , 
//   0.986491632773 , 
//   0.983868548375 , 
//   0.963627869262 , 
//   0.951537268303 , 
//   1.01178235504  
// };
// 
// 
// // 2012C ID/Iso/Trigger
// double MuonIdTight_2012C[etaBins] = {
//   0.988885203691 , 
//   0.997645965784 , 
//   0.988640905096 , 
//   0.995901914593 , 
//   0.996042652393 , 
//   0.985086426679 , 
//   0.993679777153 , 
//   0.983066759579 , 
//   0.995857745381 , 
//   0.994146529356 , 
//   0.992398250305 , 
//   1.00046379301 , 
//   1.00429584132  
// };
// 
// 
// double PFIsoIddB_eta09_2012C[ptBins] = {
//   1.00096011705 , 
//   0.995690948085 , 
//   0.994869044087 , 
//   0.994939272615 , 
//   0.996388682635 , 
//   0.998466713263 , 
//   1.00057425897 , 
//   1.00230050167  
// };
// 
// 
// double PFIsoIddB_eta09to12_2012C[ptBins] = {
//   1.00114794697 , 
//   1.00012043148 , 
//   0.99882351994 , 
//   0.998772141875 , 
//   0.997179142478 , 
//   0.998559850765 , 
//   0.997776185356 , 
//   0.997745177092  
// };
// 
// 
// double PFIsoIddB_eta12to21_2012C[ptBins] = {
//   1.00835309635 , 
//   1.00612938524 , 
//   1.00341477933 , 
//   1.00195376157 , 
//   1.00058592603 , 
//   1.0012846555 , 
//   0.999173409208 , 
//   0.994603362486  
// };
// 
// 
// double TrigId_2012C[etaBins] = {
//   0.993505794239 , 
//   0.99932115235 , 
//   0.968357227737 , 
//   0.984348692042 , 
//   0.991151581866 , 
//   0.946845904327 , 
//   0.987094067516 , 
//   0.95725034454 , 
//   0.988669415988 , 
//   0.987690315773 , 
//   0.969185226572 , 
//   0.981921303256 , 
//   1.03205674648  
// };
// 
// 
// 
// 
// // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// // !!!!            Do not remove the lines below                !!!!
// // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// int findEtaBin(_MuonInfo& mu) {
//  
//   int value = -999;
// 
//   // find the eta bins of both muons
//   for (int ieta=0; ieta<etaBins; ieta++) {
//     if ( mu.eta > etaRange[ieta] && mu.eta < etaRange[ieta+1] ) 
//       return ieta;
//   }
// 
//   return value;
// }
// 
// 
// int findPtBin(_MuonInfo& mu) {
//   
//   int value = -999;
//   //std::cout << "mu.pt = " << mu.pt <<std::endl;
//   
//   // find the eta bins of both muons
//   for (int ipt=0; ipt<ptBins; ipt++) {
//     if ( mu.pt > ptRange[ipt] && mu.pt < ptRange[ipt+1] ) 
//       return ipt;
//   }
//   
//   return value;
// }
// 
// 
// 
// // 2012 AB
// double
// weightFromSF_AB(_MuonInfo& mu1, _MuonInfo& mu2,
//                 double varMuId  , 
//                 double varIsoId ,
//                 double varTrigId)
// {
// 
//   // initialization
//   int iEta1=-999, iPt1=-999;
//   int iEta2=-999, iPt2=-999;
// 
//   iEta1=findEtaBin(mu1);
//   iPt1 =findPtBin (mu1);
// 
//   iEta2=findEtaBin(mu2);
//   iPt2 =findPtBin (mu2);
// 
//   //sanity check  
//   if (iEta1 == -999) return 1; 
//   if (iPt1  == -999) return 1; 
//   if (iEta2 == -999) return 1;
//   if (iPt2  == -999) return 1;
// 
//   // compute the weights
//   double weight = 1;
//   
//   weight *= (MuonIdTight_2012AB[iEta1]+varMuId);
//   weight *= (MuonIdTight_2012AB[iEta2]+varMuId);
// 
//   if (fabs(mu1.eta) < 0.9)   weight *= (PFIsoIddB_eta09_2012AB[iPt1]+varIsoId);
//   if (fabs(mu1.eta) > 0.9 &&
//       fabs(mu1.eta) < 1.2  ) weight *= (PFIsoIddB_eta09to12_2012AB[iPt1]+varIsoId);
//   if (fabs(mu1.eta) > 1.2 &&
//       fabs(mu1.eta) < 2.1  ) weight *= (PFIsoIddB_eta12to21_2012AB[iPt1]+varIsoId);
// 
//   if (fabs(mu2.eta) < 0.9)   weight *= (PFIsoIddB_eta09_2012AB[iPt2]+varIsoId);
//   if (fabs(mu2.eta) > 0.9 &&
//       fabs(mu2.eta) < 1.2  ) weight *= (PFIsoIddB_eta09to12_2012AB[iPt2]+varIsoId);
//   if (fabs(mu2.eta) > 1.2 &&
//       fabs(mu2.eta) < 2.1  ) weight *= (PFIsoIddB_eta12to21_2012AB[iPt2]+varIsoId);
// 
// 
//   if (mu1.isHltMatched[0] != 0) weight *= (TrigId_2012B[iEta1]+varTrigId);
//   if (mu2.isHltMatched[0] != 0) weight *= (TrigId_2012B[iEta2]+varTrigId);
// 
//   return weight;
// 
// }
// 
// // 2012C
// double
// weightFromSF_C(_MuonInfo& mu1, _MuonInfo& mu2,
//                double varMuId  , 
//                double varIsoId ,
//                double varTrigId)
// {
// 
//   // initialization
//   int iEta1=-999, iPt1=-999;
//   int iEta2=-999, iPt2=-999;
// 
//   iEta1=findEtaBin(mu1);
//   iPt1 =findPtBin (mu1);
// 
//   iEta2=findEtaBin(mu2);
//   iPt2 =findPtBin (mu2);
//   
//   //std::cout << "mu1.eta,mu1.pt = " << mu1.eta<< ", " << mu1.pt <<std::endl;
//   //std::cout << "iEta1,iPt1 = " << iEta1 << "," << iPt1 << std::endl;
//   //std::cout << "mu2.eta,mu2.pt = " << mu2.eta<< ", " << mu2.pt <<std::endl;
//   //std::cout << "iEta2,iPt2 = " << iEta2 << "," << iPt2 << std::endl;
// 
//   //sanity check  
//   if (iEta1 == -999) return 1; 
//   if (iPt1  == -999) return 1; 
//   if (iEta2 == -999) return 1;
//   if (iPt2  == -999) return 1;
// 
// 
//   // compute the weights
//   double weight = 1;
// 
//   weight *= (MuonIdTight_2012C[iEta1]+varMuId);
//   weight *= (MuonIdTight_2012C[iEta2]+varMuId);
// 
//   if (fabs(mu1.eta) < 0.9)   weight *= (PFIsoIddB_eta09_2012C[iPt1]+varIsoId);
//   if (fabs(mu1.eta) > 0.9 &&
//       fabs(mu1.eta) < 1.2  ) weight *= (PFIsoIddB_eta09to12_2012C[iPt1]+varIsoId);
//   if (fabs(mu1.eta) > 1.2 &&
//       fabs(mu1.eta) < 2.1  ) weight *= (PFIsoIddB_eta12to21_2012C[iPt1]+varIsoId);
// 
//   if (fabs(mu2.eta) < 0.9)   weight *= (PFIsoIddB_eta09_2012C[iPt2]+varIsoId);
//   if (fabs(mu2.eta) > 0.9 &&
//       fabs(mu2.eta) < 1.2  ) weight *= (PFIsoIddB_eta09to12_2012C[iPt2]+varIsoId);
//   if (fabs(mu2.eta) > 1.2 &&
//       fabs(mu2.eta) < 2.1  ) weight *= (PFIsoIddB_eta12to21_2012C[iPt2]+varIsoId);
// 
// 
//   if (mu1.isHltMatched[0] != 0) weight *= (TrigId_2012C[iEta1]+varTrigId);
//   if (mu2.isHltMatched[0] != 0) weight *= (TrigId_2012C[iEta2]+varTrigId);
// 
//   return weight;
// 
// }
// 
// 
// 
// double
// weightFromSF(double random,
//              _MuonInfo& mu1, _MuonInfo& mu2,
//              double varMuId  , 
//              double varIsoId ,
//              double varTrigId)
// {
// 
//   double weight = 1;
// 
//   // 2012AB is 5 fb-1
//   // Assume 2012C is equal to 2012D
//   // so use the 2012AB SF if the random number is < 0.25
//   //std::cout << "random = " << random << std::endl;
// 
//   if (random < 0.25) {
//     //std::cout << "2012AB values\n";
//     weight *= weightFromSF_AB(mu1,mu2, varMuId,varIsoId,varTrigId);
//   } else {
//     //std::cout << "2012C values\n";
//     weight *= weightFromSF_C (mu1,mu2, varMuId,varIsoId,varTrigId);
//   }
// 
//   return weight;
// }



// 2012AB ID/Iso
double MuonIdTight_2012AB[etaBins] = {
  0.988724932665 ,
  0.996737842371 ,
  0.986031140836 ,
  0.991124275065 ,
  0.989706987927 ,
  0.980364354197 ,
  0.987307178012 ,
  0.980522774477 ,
  0.992104552844 ,
  0.988883091109 ,
  0.99028808593 ,
  0.999737137335 ,
  0.997319526433 
};


double PFIsoIddB_eta09_2012AB[ptBins] = {
  0.991942388206 ,
  0.992135342011 ,
  0.993091518388 ,
  0.994310585549 ,
  0.995081603823 ,
  0.997969711328 ,
  0.999642125778 ,
  0.995084252461 
};


double PFIsoIddB_eta09to12_2012AB[ptBins] = {
  0.994168947061 ,
  0.996334832917 ,
  0.997334033959 ,
  0.997840943267 ,
  0.997123646502 ,
  0.996624751108 ,
  0.998533439643 ,
  0.997348599329 
};


double PFIsoIddB_eta12to21_2012AB[ptBins] = {
  0.999085718239 ,
  1.00067227076 ,
  1.00016439461 ,
  0.999862399229 ,
  1.0004112741 ,
  0.999233934088 ,
  0.997440031884 ,
  0.996480472038 
};


// Trigger efficiencies split by run periods
double TrigId_2012A[etaBins] = {
  0.986858337843 ,
  0.978316370924 ,
  0.953292931894 ,
  0.95987914314 ,
  0.961398047798 ,
  0.90902735272 ,
  0.952102875987 ,
  0.934788940021 ,
  0.965820891251 ,
  0.965678787559 ,
  0.953722570873 ,
  0.952339791663 ,
  1.00869615784 
};


double TrigId_2012B[etaBins] = {
  0.978390329954 ,
  0.983240259733 ,
  0.960283547369 ,
  0.980383168804 ,
  0.986638317618 ,
  0.941567671449 ,
  0.979740173253 ,
  0.957931506297 ,
  0.986491632773 ,
  0.983868548375 ,
  0.963627869262 ,
  0.951537268303 ,
  1.01178235504 
};


double effData_TrigId_2012B[etaBins] = {
  0.747299389079 ,
  0.82369647923 ,
  0.825505698894 ,
  0.91731220744 ,
  0.93559839346 ,
  0.842225341437 ,
  0.919600774544 ,
  0.853068640622 ,
  0.935107051693 ,
  0.919085581395 ,
  0.825425509747 ,
  0.788355383667 ,
  0.81326813281 
};


double effMC_TrigId_2012B[etaBins] = {
  0.763804962294 ,
  0.837736729224 ,
  0.859647862505 ,
  0.935667029616 ,
  0.948268860791 ,
  0.894492628598 ,
  0.938616992187 ,
  0.890531979599 ,
  0.947911792282 ,
  0.934154855253 ,
  0.856581192882 ,
  0.828507101013 ,
  0.80379750522 
};


// 2012C ID/Iso/Trigger
double MuonIdTight_2012C[etaBins] = {
  0.988885203691 ,
  0.997645965784 ,
  0.988640905096 ,
  0.995901914593 ,
  0.996042652393 ,
  0.985086426679 ,
  0.993679777153 ,
  0.983066759579 ,
  0.995857745381 ,
  0.994146529356 ,
  0.992398250305 ,
  1.00046379301 ,
  1.00429584132 
};


double PFIsoIddB_eta09_2012C[ptBins] = {
  1.00096011705 ,
  0.995690948085 ,
  0.994869044087 ,
  0.994939272615 ,
  0.996388682635 ,
  0.998466713263 ,
  1.00057425897 ,
  1.00230050167  
};


double PFIsoIddB_eta09to12_2012C[ptBins] = {
  1.00114794697 ,
  1.00012043148 ,
  0.99882351994 ,
  0.998772141875 ,
  0.997179142478 ,
  0.998559850765 ,
  0.997776185356 ,
  0.997745177092 
};


double PFIsoIddB_eta12to21_2012C[ptBins] = {
  1.00835309635 ,
  1.00612938524 ,
  1.00341477933 ,
  1.00195376157 ,
  1.00058592603 ,
  1.0012846555 ,
  0.999173409208 ,
  0.994603362486 
};


double TrigId_2012C[etaBins] = {
  0.993505794239 ,
  0.99932115235 ,
  0.968357227737 ,
  0.984348692042 ,
  0.991151581866 ,
  0.946845904327 ,
  0.987094067516 ,
  0.95725034454 ,
  0.988669415988 ,
  0.987690315773 ,
  0.969185226572 ,
  0.981921303256 ,
  1.03205674648 
};


double effData_TrigId_2012C[etaBins] = {
  0.766595741817 ,
  0.84453568564 ,
  0.841980279385 ,
  0.932696875418 ,
  0.953701730285 ,
  0.859889140733 ,
  0.941531735035 ,
  0.865874245837 ,
  0.951220788751 ,
  0.935057743014 ,
  0.840023792384 ,
  0.820795500622 ,
  0.837836289733 
};


double effMC_TrigId_2012C[etaBins] = {
  0.771606714588 ,
  0.845109386161 ,
  0.86949346302 ,
  0.947526910899 ,
  0.962215818179 ,
  0.908161652074 ,
  0.953841954906 ,
  0.90454315402 ,
  0.962122195113 ,
  0.946711462167 ,
  0.866731940761 ,
  0.835907621008 ,
  0.81181223086 
};


double TrigId_2012D[etaBins] = {
  0.996325392684 ,
  0.996709394012 ,
  0.961403094194 ,
  0.9807378886 ,
  0.987351488544 ,
  0.947109971177 ,
  0.984566165998 ,
  0.959141789157 ,
  0.985612535107 ,
  0.985765932383 ,
  0.962322189252 ,
  0.978560167836 ,
  1.01645754825 
};


double effData_TrigId_2012D[etaBins] = {
  0.756529249797 ,
  0.826816885228 ,
  0.82044391028 ,
  0.914407512793 ,
  0.933199042067 ,
  0.843924838898 ,
  0.920971940502 ,
  0.850853638616 ,
  0.931033366577 ,
  0.917330589348 ,
  0.817689735738 ,
  0.80371346111 ,
  0.812877883127 
};


double effMC_TrigId_2012D[etaBins] = {
  0.759319450605 ,
  0.829546596225 ,
  0.853381807521 ,
  0.932366867255 ,
  0.945153831127 ,
  0.891052638639 ,
  0.935408885972 ,
  0.887098913044 ,
  0.944624112837 ,
  0.930576477856 ,
  0.849704750519 ,
  0.821322477173 ,
  0.799716510076 
};


// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !!!!            Do not remove the lines below                !!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
int findEtaBin(_MuonInfo& mu) {
 
  int value = -999;

  // find the eta bins of both muons
  for (int ieta=0; ieta<etaBins; ieta++) {
    if ( mu.eta > etaRange[ieta] && mu.eta < etaRange[ieta+1] ) 
      return ieta;
  }

  return value;
}


int findPtBin(_MuonInfo& mu) {
  
  int value = -999;
  //std::cout << "mu.pt = " << mu.pt <<std::endl;
  
  // find the eta bins of both muons
  for (int ipt=0; ipt<ptBins; ipt++) {
    if ( mu.pt > ptRange[ipt] && mu.pt < ptRange[ipt+1] ) 
      return ipt;
  }
  
  return value;
}



// 2012 AB ID/ISO
double
weightFromSF_AB(_MuonInfo& mu1, _MuonInfo& mu2,
                double varMuId  , 
                double varIsoId )
{

  // initialization
  int iEta1=-999, iPt1=-999;
  int iEta2=-999, iPt2=-999;

  iEta1=findEtaBin(mu1);
  iPt1 =findPtBin (mu1);

  iEta2=findEtaBin(mu2);
  iPt2 =findPtBin (mu2);

  //sanity check  
  if (iEta1 == -999) return 1; 
  if (iPt1  == -999) return 1; 
  if (iEta2 == -999) return 1;
  if (iPt2  == -999) return 1;

  // compute the weights
  double weight = 1;
  
  weight *= (MuonIdTight_2012AB[iEta1]+varMuId);
  weight *= (MuonIdTight_2012AB[iEta2]+varMuId);

  if (fabs(mu1.eta) < 0.9)   weight *= (PFIsoIddB_eta09_2012AB[iPt1]+varIsoId);
  if (fabs(mu1.eta) > 0.9 &&
      fabs(mu1.eta) < 1.2  ) weight *= (PFIsoIddB_eta09to12_2012AB[iPt1]+varIsoId);
  if (fabs(mu1.eta) > 1.2 &&
      fabs(mu1.eta) < 2.1  ) weight *= (PFIsoIddB_eta12to21_2012AB[iPt1]+varIsoId);

  if (fabs(mu2.eta) < 0.9)   weight *= (PFIsoIddB_eta09_2012AB[iPt2]+varIsoId);
  if (fabs(mu2.eta) > 0.9 &&
      fabs(mu2.eta) < 1.2  ) weight *= (PFIsoIddB_eta09to12_2012AB[iPt2]+varIsoId);
  if (fabs(mu2.eta) > 1.2 &&
      fabs(mu2.eta) < 2.1  ) weight *= (PFIsoIddB_eta12to21_2012AB[iPt2]+varIsoId);

  return weight;

}

// 2012C
double
weightFromSF_C(_MuonInfo& mu1, _MuonInfo& mu2,
               double varMuId  , 
               double varIsoId )
{

  // initialization
  int iEta1=-999, iPt1=-999;
  int iEta2=-999, iPt2=-999;

  iEta1=findEtaBin(mu1);
  iPt1 =findPtBin (mu1);

  iEta2=findEtaBin(mu2);
  iPt2 =findPtBin (mu2);
  
  //std::cout << "mu1.eta,mu1.pt = " << mu1.eta<< ", " << mu1.pt <<std::endl;
  //std::cout << "iEta1,iPt1 = " << iEta1 << "," << iPt1 << std::endl;
  //std::cout << "mu2.eta,mu2.pt = " << mu2.eta<< ", " << mu2.pt <<std::endl;
  //std::cout << "iEta2,iPt2 = " << iEta2 << "," << iPt2 << std::endl;

  //sanity check  
  if (iEta1 == -999) return 1; 
  if (iPt1  == -999) return 1; 
  if (iEta2 == -999) return 1;
  if (iPt2  == -999) return 1;


  // compute the weights
  double weight = 1;

  weight *= (MuonIdTight_2012C[iEta1]+varMuId);
  weight *= (MuonIdTight_2012C[iEta2]+varMuId);

  if (fabs(mu1.eta) < 0.9)   weight *= (PFIsoIddB_eta09_2012C[iPt1]+varIsoId);
  if (fabs(mu1.eta) > 0.9 &&
      fabs(mu1.eta) < 1.2  ) weight *= (PFIsoIddB_eta09to12_2012C[iPt1]+varIsoId);
  if (fabs(mu1.eta) > 1.2 &&
      fabs(mu1.eta) < 2.1  ) weight *= (PFIsoIddB_eta12to21_2012C[iPt1]+varIsoId);

  if (fabs(mu2.eta) < 0.9)   weight *= (PFIsoIddB_eta09_2012C[iPt2]+varIsoId);
  if (fabs(mu2.eta) > 0.9 &&
      fabs(mu2.eta) < 1.2  ) weight *= (PFIsoIddB_eta09to12_2012C[iPt2]+varIsoId);
  if (fabs(mu2.eta) > 1.2 &&
      fabs(mu2.eta) < 2.1  ) weight *= (PFIsoIddB_eta12to21_2012C[iPt2]+varIsoId);


  return weight;

}





// 2012C
double
weightFromTrigger_AB(_MuonInfo& mu1, _MuonInfo& mu2,
                     double varTrigId)
{

  // initialization
  int iEta1=-999, iPt1=-999;
  int iEta2=-999, iPt2=-999;

  iEta1=findEtaBin(mu1);
  iPt1 =findPtBin (mu1);

  iEta2=findEtaBin(mu2);
  iPt2 =findPtBin (mu2);
  
  //std::cout << "mu1.eta,mu1.pt = " << mu1.eta<< ", " << mu1.pt <<std::endl;
  //std::cout << "iEta1,iPt1 = " << iEta1 << "," << iPt1 << std::endl;
  //std::cout << "mu2.eta,mu2.pt = " << mu2.eta<< ", " << mu2.pt <<std::endl;
  //std::cout << "iEta2,iPt2 = " << iEta2 << "," << iPt2 << std::endl;

  //sanity check  
  if (iEta1 == -999) return 1; 
  if (iPt1  == -999) return 1; 
  if (iEta2 == -999) return 1;
  if (iPt2  == -999) return 1;


  // compute the weights
  double weight = 1;

  // eff = 1 - (1-eff_mu1)*(1-eff_mu2)
  // SF = eff_Data/eff_MC
  double effHLTData = 1 - ( (1-effData_TrigId_2012B[iEta1])*(1-effData_TrigId_2012B[iEta2]) );
  double effHLTMC   = 1 - ( (1-effMC_TrigId_2012B  [iEta1])*(1-effMC_TrigId_2012B  [iEta2]) );

  double weightTrigger = effHLTData / effHLTMC;

  weight *= (weightTrigger+varTrigId);

  // debugging
  //std::cout << "weightFromTrigger_AB=" << weight << std::endl;

  return weight;

}


double
weightFromTrigger_C(_MuonInfo& mu1, _MuonInfo& mu2,
                    double varTrigId)
{

  // initialization
  int iEta1=-999, iPt1=-999;
  int iEta2=-999, iPt2=-999;

  iEta1=findEtaBin(mu1);
  iPt1 =findPtBin (mu1);

  iEta2=findEtaBin(mu2);
  iPt2 =findPtBin (mu2);
  
  //std::cout << "mu1.eta,mu1.pt = " << mu1.eta<< ", " << mu1.pt <<std::endl;
  //std::cout << "iEta1,iPt1 = " << iEta1 << "," << iPt1 << std::endl;
  //std::cout << "mu2.eta,mu2.pt = " << mu2.eta<< ", " << mu2.pt <<std::endl;
  //std::cout << "iEta2,iPt2 = " << iEta2 << "," << iPt2 << std::endl;

  //sanity check  
  if (iEta1 == -999) return 1; 
  if (iPt1  == -999) return 1; 
  if (iEta2 == -999) return 1;
  if (iPt2  == -999) return 1;


  // compute the weights
  double weight = 1;

  // eff = 1 - (1-eff_mu1)*(1-eff_mu2)
  // SF = eff_Data/eff_MC
  double effHLTData = 1 - ( (1-effData_TrigId_2012C[iEta1])*(1-effData_TrigId_2012C[iEta2]) );
  double effHLTMC   = 1 - ( (1-effMC_TrigId_2012C  [iEta1])*(1-effMC_TrigId_2012C  [iEta2]) );

  double weightTrigger = effHLTData / effHLTMC;

  weight *= (weightTrigger+varTrigId);

  // debugging
  //std::cout << "\niEta1=" << iEta1 << std::endl;
  //std::cout << "iEta2=" << iEta2 << std::endl;
  //std::cout << "effData_TrigId_2012C[iEta1]=" << effData_TrigId_2012C[iEta1] << std::endl;
  //std::cout << "effData_TrigId_2012C[iEta2]=" << effData_TrigId_2012C[iEta2] << std::endl;
  //std::cout << "effMC_TrigId_2012C[iEta1]=" << effMC_TrigId_2012C[iEta1] << std::endl;
  //std::cout << "effMC_TrigId_2012C[iEta2]=" << effMC_TrigId_2012C[iEta2] << std::endl;
  //std::cout << "effHLTData=" << effHLTData << std::endl;
  //std::cout << "effHLTMC=" << effHLTMC   << std::endl;
  //std::cout << "weightFromTrigger_C=" << weight << std::endl;

  return weight;

}




double
weightFromSF(double random,
             _MuonInfo& mu1, _MuonInfo& mu2,
             double varMuId  , 
             double varIsoId ,
             double varTrigId)
{

  double weight = 1;

  // 2012AB is 5 fb-1
  // Assume 2012C is equal to 2012D
  // so use the 2012AB SF if the random number is < 0.25
  //std::cout << "random = " << random << std::endl;

  if (random < 0.25) {
    //std::cout << "2012AB values\n";
    weight *= weightFromSF_AB(mu1,mu2, varMuId,varIsoId); // ID + ISO
    weight *= weightFromTrigger_AB(mu1,mu2, varTrigId); // Trigger
    
  } else {
    //std::cout << "2012C values\n";
    weight *= weightFromSF_C (mu1,mu2, varMuId,varIsoId); // ID + ISO
    weight *= weightFromTrigger_C(mu1,mu2, varTrigId); // Trigger
  }


  return weight;
}

